== Недочеты и открытые вопросы ==

 # Многие термины не определяются (например, текущий контейнер)
 # Не определено существенное отличие документа от контейнера. Это отличие должно описываться в функциональном смысле: документ умеет _это_, а контейнер -- нет, контейнер может _то_, а документ -- нет.
   * Документ не может в себе содержать контейнеров. И видимо поведение с изменением масштаба у контейнера не меняется, у документа меняется. Возможно это упрощение, но иначе, я не понимаю зачем нужно и то и другое.
 # Что будет, если при создании функционального контейнера область выделения захватит части нескольких соседних контейнеров?
   * Я это себе представляю так: область выделения всегда ограничивается одним контейнером (далее здесь *первоначальный* контейнер). Если мы пересекли несколько контейнеров внутри первоначального, то все пересеченные в результате будут выделены;{13}[2] если указатель мыши подходит к границам контейнера внутри которого сейчас находится область выделения, то нужно каким-то образом определять, хочет ли пользователь выделить больше чем этот контейнер, и если да, то переезажать к предку, помещая в область выделения весь первоначальный контейнер.{14}[5]
   * Также здесь нужно особо отметить случай с буфером,в котором все элементы всегда разбиты на группы, заключенные в функциональный контейнер. Хотелось бы обеспечить возможность изменения разбиения. Например, хотим вытащить один элемент из группы.  Простейшим способом явлется перетащить нужный элемент за пределы его функционального контейнера (достаточно, чтобы элемент пересекал границу). Необходимо объединение нескольких групп в одну. Предлагаю что-то аналогичное выделению: рисуем прямоугольник и новая группа --- объединение тех ф.к., с которыми он пересекается. Если этот прямоугольник внутри какого-то ф.к., то разбиваем этот ф.к. на два .{15}[5]          
 # Не описан механизм прокрутки (обсуждалось нажатие на колесо)
 # *Usability issue*: хорошо бы уметь в пределах экрана обычный Drag'n'Drop. (это можно отложить на будущее){16}[5]
 # Нет разделения функций на основные и дополнительные. То есть нужно решить, что будет делаться в первую очередь, а что -- добавляться потом.
   * [] приоритет 0 -- высокий, дальше меньше...
   * {} id функции, если без приоритета и повторяющиийся, значит это подпункт... 

== 1	Назначение системы ==
	
Разрабатываемая система представляет собой API для реализации 
масштабируемого интерфейса (zooming interface). Масштабируемый интерфейс – это относительно новая парадигма построения интерфейса, предложенная Джефом 
Раскином в книге «Интерфейс: новые направления в проектировании компьютерных 
систем». 

Принцип масштабируемого интерфейса основан на пси-эффекте – способности 
человека находить нужные нам вещи из-за склонности запоминать их относительное 
местоположение и другие ориентиры. Основными инструментами в масштабируемом интерфейсе 
являются перемещение и изменение масштаба. При этом важную роль играет способность 
элементов масштабируемого интерфейса изменять свой внешний вид и функциональность в 
зависимости от масштаба.

== 2	Функции системы ==

=== 2.1	Библиотека ===

Разрабатываемая библиотека представляет собой набор классов для реализации масштабируемого интерфейса. Библиотека поддерживает технологию MVC (Model-View-Controller). 

=== 2.1.1	Элементы интерфейса ===

Элементом интерфейса, на котором расположены все другие элементы, является так называемая плоскость информации. На ней расположены все другие элементы интерфейса. Любой фрагмент плоскости информации может быть увеличен. Диапазон изменения масштаба зависит от элемента. В частности, он может быть бесконечным, например, если данный элемент отображает график функции, увеличение масштаба будет приводить к увеличению масштаба на осях. 

Элементы интерфейса, которые могут быть расположены на плоскости информации, делятся на две группы:
 * документы – хранят информацию и предоставляют средства для ее редактирования;
 * контейнеры – используются для логической и визуальной группировки документов и других контейнеров.

=== 2.1.2     Внешний вид системы ===

 * так как пользователь может одновременно работать с разными ветками дерева иерархии компонентов, должна поддерживаться возможность дробления экрана на несколько частей;{8}[2]

 * на верху экрана всегда существует какое-то меню или подсказки комбинаций клавиш{9}[1]. В том числе там должна присутствовать клавиша Back{10}[4], нажатие и удерживание которой откатывает активную часть экрана в предыдущие состояния. А также клавиша Save, сохраняющая конфигурацию активной части экрана, создавая при этом ярлык{11}[4];

 * на экране в любой момент времени должны существовать ярлыки, в которых нужно уметь сохранять состояния системы. При активизирование ярлыка, сохраненное в нем состояние расстягивается на активную часть экрана{12}[4];

 * панель буфера и панель с ярлыками сделать по умолчанию, как всплывающие закладки.{6,12}

=== 2.1.3     Описание поведения системы ===

Пользователь смотрит на плоскость информации и находящиеся на ней элементы как бы через застекленное окно. Это окно представляет собой еще одну плоскость, на которой могут находиться элементы интерфейса. В дальнейшем будем его называть GlassPane (досл. "оконное стекло"). Одним из применений GlassPane является временное прикрепление к нему документов для их переноса (см. далее).

В каждый момент времени пользователь видит некоторую прямоугольную часть плоскости информации. При этом, пользователь может как уменьшать, так увеличивать масштаб, а также перемещаться вправо, вверх, вниз и влево.

Система элементов интерфейса имеет структуру дерева, корнем которого является плоскость информации. Таким образом, каждый элемент интерфейса непосредственно находится РОВНО В ОДНОМ контейнере. Отметим, что высота этого дерева может достигать десятков и сотен уровней. 

В каждый момент времени фокус ввода получает ровно один элемент интерфейса. При изменении масштаба фокус ввода остается у того элемента, у которого он был до изменения масштаба. Если же этот элемент уходит за пределы поля зрения, то фокус передается следующему видимому элементу в контейнере (на элементах каждого контейнера задан полный порядок, определяющий очередность получения ими фокуса). Кроме этого, пользователь может сделать активным контейнер --- в этом случае фокус ввода передается первому в заданном порядке элементу ставшего активным контейнера.

Поведение и внешний вид элементов интерфейса зависят от текущего масштаба, при этом ответственность за изменение размеров элемента "лежит" на контейнере, в котором тот находится, а ответвенность за изменение поведения --- на самом элементе.

Также поддерживается концепция "ярлыков". "Ярлык" в разрабатываемой системе содержит не только положение области, видимой пользователем, и масштаб, но и элемент интерфейса, получающий фокус ввода. Такие "ярлыки" разумно называть "ярлыками на состояние".

 * пользователь может, как уменьшать, так и увеличивать масштаб;{0}[0]

 * текущему контейнеру необходимо знать своего предка;{0}

 * при изменении масштаба фокус, по возможности, должен оставаться на том же элементе, или в том же месте текста.  Если в какой-то момент, выделенный элемент пропал из вида, фокус назначается следующему элементу (все элементы контейнера пронумерованы, после последнего идет первый). Когда меняется активный контейнер, фокус внутри контейнера переходит к первому видимому элементу (если, это текстовый документ  - к началу первой видимой строки);{1}[1]

 * при изменении масштаба, поведение компонент может меняться, поэтому контейнер должен  обходить все содержащиеся в нем компоненты, сообщая новый масштаб и фокус, а компоненты уже сами будут разбираться: видны ли они сейчас и как им себя вести в данном масштабе;{2}[0]

 * работа с группой элементов осуществляется, выделением их в прямоугольник (далее *функциональный контейнер*), при этом на сторонах этого прямоугольника появляются такие кнопки, как удалить группу, сфокусироваться на этой группе, «скопировать и прикрепить», «вырезать и прикрепить» к GlassPane, а также кнопки, зависящие от контекста. Обрамление группы в функциональный  контейнер осуществляется нажатием и удерживанием *левой* кнопки мыши;{3}[2]

 * перетаскивание элементов осуществляется нажатием *правой* кнопки мыши, при этом элемент приклеивается на экран-GlassPane (выделенный элемент перемещается вместе с указателем мыши);{4}[2]
 
 * чтобы снять с указателя мыши элемент, нужно навести указатель мыши на буфер и дважды кликнуть левой кнопкой мыши (либо просто нажать Esc), чтобы удалить из буфера элемент, висящий на мышке, нужно, находясь в буфере кликнуть дважды правой кнопкой мыши (смотри ниже пункт о свойствах удаления из буфера);{4}

 * если последовательно вырезаются два элемента, то оба они должны висеть на GlassPane. Один всегда висит на мышке + где-нибудь в углу контейнер (далее *буфер*), содержащий все выделенные когда-либо элементы;{5}[3]

 * буфер, это контейнер с исключительными свойствами. В нем отсутствует возможность масштабирования. Все элементы разбиты на группы, постоянно заключенные в функциональные контейнеры. Элементы можно перетаскивать (если новое положение элемента, вне ф.к., к которому он принадлежал, то создается отдельный ф.к.) и активизировать (при этом, элемент будет раскрываться, расстягивась по активной части экрана). Существует возможность перегруппировки. Нажатие правой кнопки в буфере, на определенной группе, вешает последнюю на мышку.{6}[3]

 * *двойной щелчок левой* клавиши мыши вставляет висящий на ней элемент и  оставляет его висящим на ней, а *двойной правой* – вставляет и удаляет из буфера и больше ничего не вешает на мышку (смотри ниже пункт о свойствах удаления из буфера);{4}

 * при удалении элемента из буфера, предоставляется возможность выбора  (в случае если до этого элемент был вырезан: вернуть элемент на место или окончательно его удалить; по умолчанию: если элемент уже был куда-то вставлен, то он удаляется, иначе возвращается на место.);{6}
 
 * при перемещении элемента из одного контейнера в другой, поведение элемента относительно нового хозяина (в плане масштаба) будет таким же, как в старом;{0}

 * при наборе текста, он не должен пропадать ни при каких обстоятельствах. То есть,  если в этот момент активен элемент, не позволяющий ввод, то создается текстовый документ,  прикрепленный к буферу;{7}[2]

=== 2.1.4	Взаимодействие пользователя с интерфейсом ===

Для взаимодействия с масштабируемым интерфейсом пользователю необходимо использовать двухкнопочную мышь с колесиком. 
При этом кнопки мыши имеют следующие функции:
 * левая кнопка – изменить фокус, то есть выбрать другой активный элемент или контейнер; 
 * правая кнопка – прикрепить  документ к GlassPane (с возможностью перетащить его на новое место); 
 * колесико – изменение  масштаба; 
 * нажатие и удерживание левой кнопки мыши + растягивание прямоугольника (drag) – создание вокруг выделенной группы документов прямоугольника с кнопками;
 * двойной щелчок левой и двойной щелчок правой – используется при вставке элементов (также эту задачу будут выполнять соответствщие ctrl-клики).


=== 2.1.4	Иерархия базовых классов библиотеки ===

Базовым суперклассом является класс ZIElement, представляющий элемент масштабируемого интерфейса. От него наследуются классы Document и Container. Плоскость информации представляется классом InformationPlane, который является потомком класса Container.
Далее, от класса Document наследуются классы TextDocument, ImageDocument, TableDocument и т.д. Для этих классов уже и существуют классы моделей: TextDocumentModel, ImageDocumentModel, TableDocumentModel и т.д. 
В модели как раз и описываются особенности поведения и внешнего вида документов в зависимости от масштаба.

=== 2.2	Средства построения интерфейса ===

При построении программы, основанной на масштабируемом интерфейсе, с помощью разработанной библиотеки, у программиста есть два пути: самому писать программный код, описывающий систему элементов интерфейса, или воспользоваться средством автоматической генерации кода. Разрабатываемое средство основано на описании мира, отображаемого в интерфейсе, в виде XML-файла.

=== 2.2.1	Структура XML-описания интерфейса ===

TBD later

=== 2.2.2	Структура генерируемого java-файла ===

TBD later

=== 2.3	Демонстрационная программа ===

В качестве примера использования разработанной библиотеки и средств построения интерфейса приводится демонстрационная программа – база данных школы.

=== 2.3.1	Описание предметной области ===

TBD later

== 3 Технические решения ==

Для реализации системы используется язык программирования Java 1.5, библиотеки-парсеры XML (DOM ?).




